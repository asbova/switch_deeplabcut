function [invalidPoints, percentInvalidPoints] = findInvalidPointsDLC(partsLocation, p, params, corners)
%
% Identify which points are valid to use for movement tracking analysis. 
%
% Input: 
%       partsLocation:                          X & Y coordinates for each bodypart for each frame (bodypart x frame number x X/Y)
%       p:                                      Likelihood values generated by Deeplabcut that bodypart was accurately label (bodypart x frame number).
%       params:                                 Parameters for evaluating DLC labeling.
%       - maxDistanceTraveledBetweenTwoFrames:  The maximum that a bodypart could reasonably travel between two frames (pixels).
%       - minValidP:                            The minimum p value that a point can have to be considered as valid.
%       - minCertainP:                          The minimum p value that a point can have to be considered as marked
%                                                   accurately without going through the maximum distance traveled assessment.
%
% Output: 
%       invalidPoints:                          Logical for each bodypart and each frame. 0 = valid point. 1 = invalid point.
%       percentInvalidPoints:                   The percentage of frames marked invalid for each bodypart.



    nBodyparts = size(partsLocation, 1);
    nFrames = size(partsLocation, 2);

    % Pass 1 - Eliminate or keep points based on p-values.
    invalidPoints = p < params.minValidP; % Eliminate any points where the p-value is too small.
    certainPoints = p > params.minCertainP; % Keep any points that are above the certainty p-value.

    % Pass 2 - Eliminate points outside the bounds of the chamber (to help with reflections that are incorrectly marked
    outPoints = zeros(nBodyparts,nFrames);
    for iBodypart = 1 : nBodyparts
        outPoints(iBodypart,:) = ~inpolygon(squeeze(partsLocation(iBodypart,:,1)), squeeze(partsLocation(iBodypart,:,2)), corners(:,1), corners(:,2));
    end

    % Pass 3 - Eliminate points that move too far between frames.
    differenceBetweenFrames = zeros(nBodyparts, nFrames-1);
    frameTravelTooFar = false(nBodyparts, nFrames);
    for iBodypart = 1 : nBodyparts
        currentPartLocation = squeeze(partsLocation(iBodypart,:,:));
        currentPartLocation(invalidPoints(iBodypart,:)',:) = NaN;

        nanFrameTravelTooFar = detectJumpsWithSurroundingNans(currentPartLocation, params);
        differenceBetweenFrames(iBodypart,:) = vecnorm(diff(currentPartLocation), 2, 2); % Calculate the euclidean distance between adjacent points.
        frameTravelTooFar(iBodypart, 1:end-1) = differenceBetweenFrames(iBodypart,:) > params.maxDistanceTraveledBetweenFrames;
        frameTravelTooFar(iBodypart, 2:end) = frameTravelTooFar(iBodypart, 1:end-1) | frameTravelTooFar(iBodypart, 2:end);
        frameTravelTooFar(iBodypart, :) = frameTravelTooFar(iBodypart,:) | isnan(invalidPoints(iBodypart,:));
        frameTravelTooFar(iBodypart, nanFrameTravelTooFar) = 1;
        %frameTravelTooFar(iBodypart, certainPoints(iBodypart,:)) = false;   % Certain points from p-value overrides distance jumps.
    end
    invalidPoints = invalidPoints | outPoints | frameTravelTooFar;

    nInvalidPoints = sum(invalidPoints,2);
    percentInvalidPoints = (nInvalidPoints / size(invalidPoints,2)) * 100;


end



function nanFrameTravelTooFar = detectJumpsWithSurroundingNans(y, params)
%
%   Function finds points that follow NaNs (i.e., certain invalid points) and detects the euclidean distance between
%   that and the last "valid" point before it that is not a NaN. The max distance permitted is the
%   params.maxDistanceTraveledBetweenframes * number of intervening NaN rows.
%
%   INPUTS:
%       y:          currentPartLocations for the current bodypart
%       params:     has the set max distance travelled between frames 
%
%   OUTPUTS:
%       nanFrameTravelTooFar:       the frames that were flagged as "jumping" too far between frames that followed NaNs
%

    rowsWithNaN = find(isnan(y(:,1)));
    frameCount = 1;
    nanFrameTravelTooFar = [];
    for jRow = 1 : length(rowsWithNaN)
        if ~isnan(y(rowsWithNaN(jRow) + 1,1))
            
            findingNans = diff(rowsWithNaN(1 :jRow)); % count back the number of NaN rows before a non-NaN point
            if all(findingNans == 1)
                nNans = sum(findingNans) + 1;
            else
                nNans = length(findingNans(find(findingNans > 1, 1, 'last') + 1 : end)) + 1;
            end
            maxPixels = params.maxDistanceTraveledBetweenFrames * (nNans+1);
            if rowsWithNaN(jRow) - nNans == 0 % The first point is a NaN
                continue;
            else
                if vecnorm(y(rowsWithNaN(jRow)+1,:) - y(rowsWithNaN(jRow) - nNans,:)) > maxPixels
                    nanFrameTravelTooFar(frameCount) = rowsWithNaN(jRow) + 1;
                    rowsWithNaN(jRow+2:end+1) = rowsWithNaN(jRow+1 : end);
                    rowsWithNaN(jRow+1) = rowsWithNaN(jRow) + 1;
                    frameCount = frameCount + 1;
                else
                    % The point is within a reasonable distance from the previous non-nan frame.
                end
            end
        else
            continue;
        end
    end
end